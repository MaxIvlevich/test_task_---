# User Management REST API

Это REST API для управления пользователями, разработанное в рамках тестового задания на позицию Java Backend разработчика. Приложение реализовано на Java 17 с использованием Spring Boot 3 и следует современным практикам разработки, включая SOLID, KISS, DRY, полную Docker-изацию и покрытие автотестами.

## Функциональные возможности

*   **CRUD для пользователей:** Полное управление пользователями, включая контактную и детальную информацию.
*   **CRUD для аватаров:** Загрузка, обновление и удаление фотографий (аватаров) пользователей.
*   **Продвинутая аутентификация:** Реализована аутентификация на основе JWT (Access + Refresh Token), обеспечивающая безопасность API.
*   **Ролевая модель:** Базовая система ролей (`ROLE_USER`, `ROLE_ADMIN`).
*   **Пагинация и сортировка:** Получение списков пользователей с поддержкой пагинации и сортировки.
*   **Централизованная обработка ошибок:** API возвращает стандартизированные и понятные JSON-ответы для всех типов ошибок.

## Технологический стек

*   **Язык:** Java 17
*   **Фреймворк:** Spring Boot 3
*   **Доступ к данным:** Spring Data JPA / Hibernate
*   **База данных:** PostgreSQL
*   **Управление миграциями БД:** Liquibase
*   **Хранилище файлов:** MinIO (S3-совместимое объектное хранилище)
*   **Безопасность:** Spring Security (JWT)
*   **Контейнеризация:** Docker, Docker Compose
*   **Тестирование:** JUnit 5, Mockito, Testcontainers
*   **Сборка:** Maven

## Архитектура и структура базы данных

Приложение спроектировано с четким разделением данных на аутентификационную и персональную информацию для оптимизации производительности и следования принципу разделения ответственности.

### Структура таблиц:

1.  **`users`**
    *   Хранит основную информацию для аутентификации и контактов.
    *   **Поля:** `id` (UUID), `username`, `password`, `email`, `phone_number`.

2.  **`user_roles`**
    *   Таблица связи для реализации ролевой модели (многие-ко-многим между пользователями и ролями).
    *   **Поля:** `user_id`, `role`.

3.  **`user_data`**
    *   Хранит детальную (персональную) информацию о пользователе. Связана с таблицей `users` отношением "один-к-одному".
    *   **Поля:** `user_id` (PK, FK), `first_name`, `last_name`, `patronymic`, `date_of_birth`, `avatar_key`.

4.  **`refresh_tokens`**
    *   Хранит refresh-токены для механизма обновления JWT.
    *   **Поля:** `id`, `user_id`, `token`, `expiry_date`.

## Запуск проекта

Для запуска проекта вам понадобится установленный **Docker** и **Docker Compose**.

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/MaxIvlevich/user-management-api.git
    cd user-management-api
    ```

2.  **Настройте переменные окружения:**
    В корне проекта находится файл-шаблон `.env.example`. Скопируйте его в новый файл `.env`:
    ```bash
    cp .env.example .env
    ```
    Откройте файл `.env` и, при необходимости, измените значения. **Важно:** рекомендуется заменить `JWT_SECRET` на ваш собственный сгенерированный ключ для повышения безопасности.

3.  **Запустите все сервисы с помощью Docker Compose:**
    Эта команда соберет образ Java-приложения и запустит все необходимые контейнеры (приложение, PostgreSQL, MinIO) в фоновом режиме.
    ```bash
    docker-compose up --build -d
    ```

4.  **Готово!**
    *   REST API будет доступно по адресу `http://localhost:8080`
    *   Веб-интерфейс MinIO будет доступен по адресу `http://localhost:9001` (Логин: `minioadmin`, Пароль: `minioadmin`).
    *   При первом запуске автоматически будет создан пользователь-администратор с учетными данными: `admin` / `admin`.

## Тестирование API

Для тестирования API рекомендуется использовать [Postman](https://www.postman.com/). В корне проекта находится экспортированная коллекция Postman `User-API.postman_collection.json`, которую можно импортировать.

Коллекция содержит все необходимые запросы для тестирования CRUD, аутентификации и загрузки аватаров, а также скрипты для автоматического сохранения и использования JWT.

**Основной сценарий использования:**
1.  Выполните запрос `[AUTH] Sign In` с телом `{"identifier": "admin", "password": "admin"}` для получения JWT.
2.  Все остальные запросы в коллекции автоматически используют полученный токен для аутентификации.
